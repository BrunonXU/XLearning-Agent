# Day 2-3：RAG 闭环 + Agent 核心逻辑

> 📅 **计划**：Day 2 - RAG 最小闭环 / Day 3 - Agent 完善
> 📦 **产出**：可用的知识问答系统 + 三个功能 Agent
> ⏱️ **阅读时间**：40-50 分钟

---

## 写在前面：这两天解决了什么问题？

Day 1 我们搭好了骨架，但它只是个"空壳"——能 import，但不能真正干活。

Day 2-3 让这个系统真正**能用**了：
- 用户上传 PDF → 系统能读懂并存进知识库
- 用户提问 → 系统能基于知识库回答
- 用户想学习 → 系统能生成计划、出题测验

---

## 第一章：RAG 的完整闭环

### 1.1 为什么 LLM 需要 RAG？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LLM 的两大致命问题                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   问题 1：知识有截止日期                                                      │
│   ──────────────────────                                                    │
│   GPT-4 的知识截止到 2023 年，你问它 2024 年的事，它不知道                     │
│                                                                             │
│   问题 2：不认识你的私有数据                                                  │
│   ───────────────────────                                                   │
│   你有一份内部技术文档，GPT-4 没见过，它回答不了                               │
│                                                                             │
│   ────────────────────────────────────────────────────────────────────      │
│                                                                             │
│   RAG 的解决思路：                                                           │
│   ──────────────                                                            │
│   把你的文档存起来，用户提问时先从文档里找相关内容，                            │
│   然后把找到的内容和问题一起发给 LLM，让它基于这些内容回答                      │
│                                                                             │
│   类比：LLM 是一个聪明但没读过你资料的专家，                                   │
│         RAG 就是在提问前先把相关资料递给他看                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 RAGEngine 新增了什么？

Day 1 的 RAGEngine 只有基础的 `add_document()` 和 `retrieve()`。

Day 2 新增了 **`query_with_context()`** —— 这是 RAG 问答的核心方法。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      query_with_context() 做了什么                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   用户问题："什么是 Self-Attention？"                                        │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ 第一步：检索相关内容                                               │     │
│   │                                                                    │     │
│   │ 调用 retrieve() 从 ChromaDB 找出最相关的 5 段文字                   │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ 第二步：构建增强 Prompt                                            │     │
│   │                                                                    │     │
│   │ "请根据以下参考资料回答问题：                                        │     │
│   │  [资料1] Self-Attention 是 Transformer 的核心机制...                │     │
│   │  [资料2] Attention 计算公式是 softmax(QK^T/sqrt(d_k))V...           │     │
│   │                                                                    │     │
│   │  问题：什么是 Self-Attention？"                                     │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ 第三步：调用 LLM 生成回答                                          │     │
│   │                                                                    │     │
│   │ LLM 看到了资料，能够给出准确、有依据的回答                           │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：`src/rag/engine.py` 的 `query_with_context()` 方法

**这个方法解决的问题**：把"检索"和"生成"串起来，形成完整的 RAG 问答闭环。

### 1.3 面试考点

> **面试官：说说你对 RAG 的理解？**
>
> **回答**："RAG 是 Retrieval-Augmented Generation 的缩写，核心思想是**先检索再生成**。我项目里的实现是：先用 Embedding 把用户问题向量化，在 ChromaDB 里检索 Top-K 相关文档，然后把这些文档拼接到 Prompt 里发给 LLM。这样 LLM 就能基于用户自己的数据回答问题，而不是只靠预训练知识。"

> **面试官追问：检索的准确率怎么保证？**
>
> **回答**："主要靠三个因素：一是**切分策略**，我用 chunk_size=1000、overlap=200 保证语义完整；二是**Embedding 质量**，用的是 DashScope 的 Embedding 模型；三是**Top-K 值**，我选 5 是平衡召回率和噪声的经验值。如果要进一步优化，可以加 Reranker 做二次排序。"

---

## 第二章：PDF → RAG 的完整链路

### 2.1 PDFAnalyzer 做了什么？

用户上传 PDF 后，系统需要：
1. 解析 PDF 内容（提取文字）
2. 转换成结构化数据
3. 导入 RAG 知识库

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      PDF 处理完整流程                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   用户上传 PDF                                                               │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ PDFAnalyzer.analyze_from_bytes()                                  │     │
│   │                                                                    │     │
│   │ • 接收 PDF 二进制数据                                              │     │
│   │ • 用 PyMuPDF 解析每一页                                            │     │
│   │ • 提取文字内容                                                     │     │
│   │ • 输出：PDFContent 对象                                            │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ PDFAnalyzer.to_learning_context()                                 │     │
│   │                                                                    │     │
│   │ • 把 PDFContent 转成纯文本格式                                     │     │
│   │ • 添加标题、页数等元信息                                            │     │
│   │ • 输出：适合 RAG 导入的文本                                         │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ PDFAnalyzer.import_to_rag()  ← Day 2 新增                         │     │
│   │                                                                    │     │
│   │ • 调用 to_learning_context() 获取文本                              │     │
│   │ • 调用 rag_engine.add_document() 存入知识库                        │     │
│   │ • 输出：导入的 chunk IDs                                           │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 为什么要单独封装 import_to_rag()？

之前如果要导入 PDF，调用方需要写：

```python
# 以前的写法（3 步）
pdf_content = analyzer.analyze_from_bytes(file_bytes)
text = analyzer.to_learning_context(pdf_content)
rag_engine.add_document(text, metadata)
```

现在只需要：

```python
# 现在的写法（1 步）
analyzer.import_to_rag(pdf_content, rag_engine)
```

**这叫"封装"** —— 把多个步骤合并成一个方法，调用方不需要知道内部细节。

### 2.3 面试考点

> **面试官：你的 PDF 处理流程是怎样的？**
>
> **回答**："分三步：第一步用 PyMuPDF 解析 PDF 提取文字；第二步转换成适合 RAG 的格式，加上标题、页数等元信息；第三步调用 RAGEngine 做切分、向量化、存入 ChromaDB。我封装了一个 `import_to_rag()` 方法，一行代码完成整个流程。"

> **面试官追问：PDF 解析会遇到什么问题？**
>
> **回答**："最常见的问题是**扫描版 PDF**，只有图片没有文字，PyMuPDF 提取不出内容。解决方案是接入 OCR（比如 Tesseract），但我项目里暂时只支持文本 PDF，这个作为 TODO 留着以后扩展。"

---

## 第三章：三个 Agent 详解

### 3.1 TutorAgent：教学互动

**职责**：回答用户的学习问题，可以基于 RAG 知识库回答。

**Day 2 新增了什么？**

新增 `answer()` 方法 —— 一个更简洁的问答接口。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      answer() vs run() 的区别                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   run() 方法（Day 1 就有）                                                   │
│   ─────────────────────                                                     │
│   • 功能完整但参数多                                                         │
│   • 需要指定 mode（FREE/QUIZ）                                               │
│   • 需要手动控制是否用 RAG                                                   │
│                                                                             │
│   answer() 方法（Day 2 新增）                                                │
│   ───────────────────────                                                   │
│   • 简化版的问答接口                                                         │
│   • 默认使用 FREE 模式                                                       │
│   • 自动使用 RAG（如果有的话）                                               │
│   • 调用方只需要传问题就行                                                    │
│                                                                             │
│   为什么要这样设计？                                                          │
│   ─────────────────                                                         │
│   • run() 给需要精细控制的场景用                                             │
│   • answer() 给 90% 的普通问答场景用                                         │
│   • 这叫"提供多层次 API"                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：`src/agents/tutor.py` 的 `answer()` 方法

### 3.2 PlannerAgent：生成学习计划

**职责**：分析用户输入（领域描述/GitHub URL/PDF），生成个性化学习计划。

**Day 2-3 完善了什么？**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      PlannerAgent 输入类型检测                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   用户输入                                                                   │
│        │                                                                    │
│        ▼                                                                    │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ _detect_input_type()                                              │     │
│   │                                                                    │     │
│   │ 判断逻辑：                                                         │     │
│   │ • 以 "https://github.com" 开头 → github_url                        │     │
│   │ • 内容长度 > 1000 字符 → pdf_content                               │     │
│   │ • 其他 → domain_description                                        │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│        │                                                                    │
│        ├─────────────┬─────────────┐                                        │
│        ▼             ▼             ▼                                        │
│   ┌─────────┐  ┌─────────┐  ┌────────────┐                                 │
│   │ GitHub  │  │   PDF   │  │  普通文本   │                                 │
│   │ 调用     │  │ 截取前  │  │  直接用     │                                 │
│   │ Repo    │  │ 3000字  │  │  作为领域   │                                 │
│   │ Analyzer│  │ 作背景  │  │  描述       │                                 │
│   └─────────┘  └─────────┘  └────────────┘                                 │
│        │             │             │                                        │
│        └─────────────┴─────────────┘                                        │
│                      │                                                      │
│                      ▼                                                      │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │ 调用 LLM 生成学习计划                                              │     │
│   │ 返回 LearningPlan 对象                                             │     │
│   └──────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：
- `src/agents/planner.py` 的 `_detect_input_type()` 方法
- `src/agents/planner.py` 的 `_process_github_url()` 方法

### 3.3 ValidatorAgent：出题测验

**职责**：生成测验题目、评估答案、生成进度报告。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      ValidatorAgent 三大功能                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   功能 1：generate_quiz()                                                    │
│   ──────────────────────                                                    │
│   • 输入：主题 + 参考内容 + 题目数量 + 难度                                   │
│   • 调用 LLM 生成 JSON 格式的选择题                                          │
│   • 解析 JSON 转成 Quiz 对象                                                │
│   • 输出：Quiz（包含多个 Question）                                          │
│                                                                             │
│   功能 2：evaluate_answers()                                                 │
│   ─────────────────────────                                                 │
│   • 输入：Quiz + 用户答案列表                                                │
│   • 逐题比对正确答案                                                         │
│   • 记录错误的知识点                                                         │
│   • 输出：QuizResult（正确率、薄弱点、反馈）                                  │
│                                                                             │
│   功能 3：generate_report()                                                  │
│   ────────────────────────                                                  │
│   • 输入：领域名称                                                           │
│   • 统计历史测验数据                                                         │
│   • 分析薄弱环节                                                             │
│   • 输出：ProgressReport（总结 + 建议）                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：`src/agents/validator.py`

### 3.4 三个 Agent 的面试考点

> **面试官：你的 Agent 是怎么设计的？**
>
> **回答**："我设计了三个职责明确的 Agent：PlannerAgent 负责分析输入、生成学习计划，它能自动识别 GitHub URL 还是普通文本；TutorAgent 负责互动教学，集成了 RAG 检索，能基于用户资料回答问题；ValidatorAgent 负责评估，能出题、判卷、生成进度报告。它们都继承自 BaseAgent，通过依赖注入获取 LLM Provider。"

> **面试官追问：Agent 之间怎么协作？**
>
> **回答**："通过 Orchestrator 协调。它根据用户意图路由到不同 Agent，还管理 RAG 引擎的共享——所有 Agent 都可以访问同一个知识库。比如 Planner 生成的计划会存入 RAG，后续 Tutor 回答问题时就能检索到。"

---

## 第四章：Orchestrator 调度逻辑

### 4.1 意图识别的优先级问题

Day 2-3 修复了一个重要的 Bug。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      意图识别的 Bug 修复                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   原来的代码（有 Bug）：                                                      │
│   ─────────────────────                                                     │
│   if "计划" or "开始" in user_input:                                         │
│       return "create_plan"                                                  │
│                                                                             │
│   问题在哪？                                                                 │
│   ─────────                                                                 │
│   Python 会先计算 "计划" or "开始"，结果是 "计划"（非空字符串为 True）         │
│   然后判断 "计划" in user_input                                              │
│   但如果用户说"开始测验"，也会被误判为 create_plan                             │
│                                                                             │
│   ────────────────────────────────────────────────────────────────────      │
│                                                                             │
│   修复后的代码：                                                              │
│   ─────────────                                                             │
│   # 优先级：测验 > 报告 > 计划 > 问答                                         │
│   if any(kw in input for kw in ["测验", "quiz"]):                           │
│       return "start_quiz"                                                   │
│   elif any(kw in input for kw in ["报告", "进度"]):                          │
│       return "get_report"                                                   │
│   elif any(kw in input for kw in ["计划", "plan"]):                         │
│       return "create_plan"                                                  │
│   else:                                                                     │
│       return "ask_question"                                                 │
│                                                                             │
│   为什么测验优先级最高？                                                      │
│   ─────────────────────                                                     │
│   因为"开始测验"包含"开始"，如果计划优先级高会被误判                           │
│   而"测验"这个词几乎不会出现在其他场景                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：`src/agents/orchestrator.py` 的 `_detect_intent()` 方法

### 4.2 process_file() 文件处理

Day 2-3 新增了文件处理能力，用户上传 PDF 后自动导入 RAG。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      文件处理流程                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   用户在 UI 上传 PDF                                                         │
│        │                                                                    │
│        ▼                                                                    │
│   Orchestrator.process_file(file_bytes, filename)                           │
│        │                                                                    │
│        ├── 判断文件类型（目前只支持 .pdf）                                    │
│        │                                                                    │
│        ▼                                                                    │
│   PDFAnalyzer.analyze_from_bytes()                                          │
│        │                                                                    │
│        ▼                                                                    │
│   PDFAnalyzer.import_to_rag(pdf_content, self.rag_engine)                   │
│        │                                                                    │
│        ▼                                                                    │
│   返回成功消息，告诉用户已导入知识库                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键代码位置**：`src/agents/orchestrator.py` 的 `process_file()` 方法

### 4.3 面试考点

> **面试官：你的意图识别是怎么做的？**
>
> **回答**："目前是基于关键词匹配，按优先级判断：测验 > 报告 > 计划 > 问答。这是最简单的实现，优点是快、没有 API 调用；缺点是不够智能。后续可以升级成用 LLM 做意图分类，或者用 LangGraph 的条件边实现更复杂的路由。"

> **面试官追问：关键词匹配会有什么问题？**
>
> **回答**："主要问题是**歧义**。比如用户说'帮我制定一个测验计划'，同时包含'测验'和'计划'，按我的优先级会识别为测验，但用户其实想要计划。解决方案是用 LLM 做意图识别，或者让用户在 UI 上直接点按钮选择。"

---

## 第五章：你修复的 Bug

### 5.1 LLMResponse.usage 类型问题

**问题描述**：
通义千问返回的 usage 字段是嵌套结构（有 `prompt_tokens`、`completion_tokens` 等），但我们定义的类型是 `Dict[str, int]`，实际值可能是嵌套的 dict。

**修复方案**：
```python
# 修复前
usage: Optional[Dict[str, int]] = None

# 修复后
usage: Optional[Dict[str, Any]] = None  # Any 兼容嵌套结构
```

**关键代码位置**：`src/providers/base.py` 的 `LLMResponse` 类

### 5.2 LearningPlan.raw_markdown 新增字段

**问题描述**：
LLM 生成的学习计划是 Markdown 格式，我们解析成结构化的 `LearningPlan` 对象。但解析可能丢失一些信息（比如 LLM 写的额外说明），需要保留原始输出。

**修复方案**：
```python
class LearningPlan(BaseModel):
    # ... 其他字段
    raw_markdown: str = ""  # 新增：保留 LLM 原始输出
```

**为什么这样设计**：
- UI 展示时可以直接用 `raw_markdown`（保留 LLM 的完整表述）
- 结构化字段用于后续逻辑处理（比如按阶段显示进度）
- 两者互补，不冲突

**关键代码位置**：`src/core/models.py` 的 `LearningPlan` 类

### 5.3 面试考点

> **面试官：开发过程中遇到过什么坑？**
>
> **回答**："印象最深的是类型问题。LLM 返回的 usage 字段是嵌套 dict，但我定义的类型是 `Dict[str, int]`，导致 Pydantic 验证报错。解决方案是用 `Dict[str, Any]` 兼容嵌套结构。这让我学到定义 API 返回值类型时要考虑实际数据的复杂性。"

---

## 第六章：测试验证

### 6.1 你写的测试脚本做了什么？

| 测试文件 | 验证内容 | 结果 |
|---------|---------|------|
| `test_rag_e2e.py` | 添加文档 → 检索 → RAG 问答 | ✅ |
| `test_day2_complete.py` | Provider + RAG + PDFAnalyzer + TutorAgent | ✅ 4/4 |
| `test_day3_agents.py` | PlannerAgent + ValidatorAgent + Orchestrator + 端到端 | ✅ 4/4 |

### 6.2 面试考点

> **面试官：你怎么保证代码质量？**
>
> **回答**："我写了三层测试：单元测试验证单个方法、集成测试验证模块协作、端到端测试验证完整流程。比如 `test_rag_e2e.py` 会真正调用 LLM 和 ChromaDB，验证 RAG 问答能跑通。每天开发完都要跑一遍测试确保没有 regression。"

---

## 总结：Day 2-3 产出清单

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Day 2-3 新增/修改内容                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   RAGEngine                                                                 │
│   ─────────                                                                 │
│   ✅ query_with_context() - RAG 问答核心                                    │
│                                                                             │
│   PDFAnalyzer                                                               │
│   ───────────                                                               │
│   ✅ import_to_rag() - PDF → RAG 一键导入                                   │
│                                                                             │
│   TutorAgent                                                                │
│   ──────────                                                                │
│   ✅ answer() - 简化版 RAG 问答接口                                         │
│                                                                             │
│   PlannerAgent                                                              │
│   ────────────                                                              │
│   ✅ _detect_input_type() - 输入类型检测                                    │
│   ✅ _process_github_url() - GitHub URL 处理                                │
│                                                                             │
│   Orchestrator                                                              │
│   ────────────                                                              │
│   ✅ _detect_intent() - 意图识别优先级修复                                  │
│   ✅ process_file() - 文件处理流程                                          │
│                                                                             │
│   Bug 修复                                                                   │
│   ────────                                                                  │
│   ✅ LLMResponse.usage 类型修复                                             │
│   ✅ LearningPlan.raw_markdown 新增字段                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**👉 下一步**：Day 4 - UI 与 Orchestrator 连接
